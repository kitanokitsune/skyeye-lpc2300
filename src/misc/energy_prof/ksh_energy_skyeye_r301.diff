Index: utils/main/skyeye.c
===================================================================
--- utils/main/skyeye.c	(revision 301)
+++ utils/main/skyeye.c	(working copy)
@@ -148,7 +148,7 @@
 
 			if (state->EndCondition == 0) {
 				//chy 20050729 ????
-				printf ("error in sim_resume for state->EndCondition");
+				fprintf (stderr, "error in sim_resume for state->EndCondition");
 				skyeye_exit (-1);
 			}
 		}
@@ -547,6 +547,14 @@
 /* 2007-01-31 disabled by Anthony Lee on BeOS for multi-thread safe. */
 void sigint_handler (int signum)
 {
+	if (state->energy.outfile) { 
+        	ARMul_ReportEnergy(state,state->energy.outfile); /* <tktan> BUG200104111423, BUG200105222137 */
+               	fprintf(state->energy.outfile, "total instructions = %lld\n", state->NumInstrs);
+               	fprintf(state->energy.outfile, "total cycles = %lld\n", state->energy.tcycle) ;
+               	fprintf(state->energy.outfile, "total energy = %lf\n", state->energy.t_energy) ;
+		fclose(state->energy.outfile);
+        }
+
 	longjmp (ctrl_c_cleanup, 1);
 }
 #endif
Index: arch/arm/common/armsym.c
===================================================================
--- arch/arm/common/armsym.c	(revision 301)
+++ arch/arm/common/armsym.c	(working copy)
@@ -22,133 +22,125 @@
 #include "armdefs.h"
 
 
-static char itoa_tab[16] =
-	{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c',
-'d', 'e',
-	'f'
-};
-static int storage_needed;
+static char itoa_tab[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'} ;
+static long storage_needed;
 static asymbol **symbol_table;
-static unsigned int number_of_symbols, kernel_number;
+static unsigned long number_of_symbols, kernel_number;
 
-static SYM_FUNC trap_sym = { "Trap", 0, 0, 0 };
-static SYM_FUNC init_sym = { "Init", 0, 0, 0 };	/* <tktan> BUG200103311736 */
-static FUNC_NODE init_node = { &init_sym, 0, 0, 0 };
+static SYM_FUNC trap_sym = {"Trap", 0, 0, 0};
+static SYM_FUNC init_sym = {"Init", 0, 0, 0}; /* <tktan> BUG200103311736 */
+static FUNC_NODE init_node = {&init_sym, 0, 0,0};
 static ARMword debug;
 #if 0
-void
-ARMul_InitSymTable ()
+void ARMul_InitSymTable()
 {
-	int i, j, digit;
-	ENTRY newentry, *oldentry;
-	SYM_FUNC *symp;
-	asymbol *symptr;
-	int key;
-	bfd *appl_bfd;
-	bfd *abfd;
-	int appl_storage_needed;
+  long i,j, digit;
+  ENTRY newentry, *oldentry;
+  SYM_FUNC *symp;
+  asymbol *symptr;
+  int key;
+  bfd *appl_bfd;
+  bfd *abfd;	
+  long appl_storage_needed;
 
 	abfd = bfd_openr ("./vmlinux", 0);
-	/* <tktan> BUG200105221946 : get symbol from usrappl */
-	appl_bfd = bfd_openr ("init/usrappl", 0);
-	if (appl_bfd == NULL) {
-		printf ("Can't open init/usrappl\n");
-		exit (0);
-	}
+  /* <tktan> BUG200105221946 : get symbol from usrappl */
+  appl_bfd = bfd_openr ("init/usrappl", 0);
+  if (appl_bfd == NULL)
+  {
+    printf("Can't open init/usrappl\n");
+    exit(0);
+  }
 
-	if (!bfd_check_format (appl_bfd, bfd_object)) {
-		printf ("Wrong format\n");
-		exit (0);
-	}
+  if (!bfd_check_format(appl_bfd, bfd_object)) {
+    printf("Wrong format\n") ;
+    exit(0);
+  }
 
-	appl_storage_needed = bfd_get_symtab_upper_bound (appl_bfd);
-	if (appl_storage_needed < 0) {
-		printf ("FAIL\n");
-		exit (0);
-	}
-	/* <tktan> BUG200105221946 */
+  appl_storage_needed = bfd_get_symtab_upper_bound(appl_bfd);
+  if (appl_storage_needed < 0){
+    printf("FAIL\n");
+    exit(0);
+  }
+  /* <tktan> BUG200105221946 */
 
-	if (!bfd_check_format (abfd, bfd_object)) {
-		printf ("Wrong format\n");
-		exit (0);
-	}
+  if (!bfd_check_format(abfd, bfd_object)) {
+    printf("Wrong format\n") ;
+    exit(0);
+  }
 
-	storage_needed = bfd_get_symtab_upper_bound (abfd);
-	if (storage_needed < 0) {
-		printf ("FAIL\n");
-		exit (0);
-	}
+  storage_needed = bfd_get_symtab_upper_bound(abfd);
+  if (storage_needed < 0){
+    printf("FAIL\n");
+    exit(0);
+  }
 
-	// <tktan> BUG200105221946 :symbol_table = (asymbol **) malloc (storage_needed);
-	symbol_table =
-		(asymbol **) malloc (appl_storage_needed + storage_needed);
+  // <tktan> BUG200105221946 :symbol_table = (asymbol **) malloc (storage_needed);
+  symbol_table = (asymbol **) malloc (appl_storage_needed + storage_needed);
 
-	number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);
-	kernel_number = number_of_symbols;	/* <tktan> BUG200106022219 */
+  number_of_symbols =
+     bfd_canonicalize_symtab (abfd, symbol_table);
+  kernel_number = number_of_symbols; /* <tktan> BUG200106022219 */
 
-	if (number_of_symbols < 0) {
-		printf ("FAIL\n");
-		exit (0);
-	}
+  if (number_of_symbols < 0){
+    printf("FAIL\n");
+    exit(0);
+  }
 
-	/* <tktan> BUG200105221946 */
-	number_of_symbols +=
-		bfd_canonicalize_symtab (appl_bfd,
-					 &(symbol_table[number_of_symbols]));
+  /* <tktan> BUG200105221946 */
+  number_of_symbols += bfd_canonicalize_symtab(appl_bfd, &(symbol_table[number_of_symbols]));
 
-	// printf("Number of symbols = %d\n", number_of_symbols) ;
+  // printf("Number of symbols = %d\n", number_of_symbols) ;
 
-	if (!hcreate (number_of_symbols << 1)) {
-		printf ("Not enough memory for hash table\n");
-		exit (0);
-	}
-	for (i = 0; i < number_of_symbols; i++) {
-		symptr = symbol_table[i];
-		key = symptr->value + symptr->section->vma;	// adjust for section address
+  if (!hcreate(number_of_symbols << 1)) {
+    printf("Not enough memory for hash table\n");
+    exit(0);
+  }
+  for (i = 0; i < number_of_symbols; i++) {
+    symptr = symbol_table[i] ;
+    key = symptr->value + symptr->section->vma; // adjust for section address
 
-		if (((i < kernel_number) && (symbol_table[i]->flags == 0x01)) ||	// <tktan> BUG200105172154, BUG200106022219 
-		    ((i < kernel_number) && (symbol_table[i]->flags == 0x02)) ||	// <tktan> BUG200204051654
-		    (symbol_table[i]->flags & 0x10)) {	// Is a function symbol
-			// printf("%x %8x %s\n", symbol_table[i]->flags, key, symbol_table[i]->name);
+    if (((i<kernel_number) && (symbol_table[i]->flags == 0x01)) || // <tktan> BUG200105172154, BUG200106022219 
+	((i<kernel_number) && (symbol_table[i]->flags == 0x02)) || // <tktan> BUG200204051654
+	(symbol_table[i]->flags & 0x10)) { // Is a function symbol
+      // printf("%x %8x %s\n", symbol_table[i]->flags, key, symbol_table[i]->name);
 
-			// ***********************************************************
-			// This is converting the function symbol value to char string
-			// and use it as a key in the GNU hash table
-			// ********************************************************
-			newentry.key = (char *) malloc (9);
-			for (j = 0; j < 8; j++) {
-				newentry.key[j] =
-					itoa_tab[((key) >> (j << 2)) & 0xf];
-			}
-			newentry.key[8] = 0;
+      // ***********************************************************
+      // This is converting the function symbol value to char string
+      // and use it as a key in the GNU hash table
+      // ********************************************************
+      newentry.key = (char *) malloc(9);
+      for (j=0;j<8;j++) {
+        newentry.key[j] = itoa_tab[((key) >> (j << 2)) & 0xf] ;
+      }
+      newentry.key[8] = 0 ;
 
-			// *************************************************
-			// This is allocating memory for a struct funcsym
-			// *************************************************
-			symp = (SYM_FUNC *) malloc (sizeof (SYM_FUNC));
-			newentry.data = (char *) symp;
-			symp->name = (char *) symbol_table[i]->name;
-			symp->total_cycle = 0;
-			symp->total_energy = 0;
-			symp->instances = 0;
+      // *************************************************
+      // This is allocating memory for a struct funcsym
+      // *************************************************
+      symp = (SYM_FUNC *) malloc(sizeof(SYM_FUNC));
+      newentry.data = (char *) symp; 
+      symp->name = (char *) symbol_table[i]->name ;
+      symp->total_cycle = 0;
+      symp->total_energy = 0;
+      symp->instances = 0;
 
-			// ***********************************************
-			// Insert into hash table
-			// *******************************************
-			/* <tktan> BUG200106022219 */
-			oldentry = hsearch (newentry, FIND);
-			if (oldentry) {	// was entered
-				// printf("Duplicate Symbol: %x %s\n", key, symp->name);
-				oldentry->data = (char *) symp;
-			}
-			else if (!hsearch (newentry, ENTER)) {
-				printf ("Insufficient memory\n");
-				exit (0);
-			}
-		}
-	}
+      // ***********************************************
+      // Insert into hash table
+      // *******************************************
+      /* <tktan> BUG200106022219 */
+      oldentry = hsearch(newentry, FIND) ;
+      if (oldentry) { // was entered
+        // printf("Duplicate Symbol: %x %s\n", key, symp->name);
+        oldentry->data = (char *) symp ;	
+      } else if (!hsearch(newentry, ENTER)) { 
+        printf("Insufficient memory\n");
+        exit(0) ;
+      }
+    }
+  }
 
-	return;
+  return;
 }
 
 #else
@@ -161,103 +153,100 @@
 **************************************************************************/
 /***************
  * added by ksh
- ***************/
-void
-ARMul_InitSymTable (char *filename)
+ ***************/ 
+void ARMul_InitSymTable(char* filename)
 {
-	int i, j, digit;
-	ENTRY newentry, *oldentry;
-	SYM_FUNC *symp;
-	asymbol *symptr;
-	int key;
-	bfd *abfd;
-	printf ("call ARMul_InitSymTable,kernle filename is %s. \n",
-		filename);
+  long i,j, digit;
+  ENTRY newentry, *oldentry;
+  SYM_FUNC *symp;
+  asymbol *symptr;
+  int key;
+  bfd *abfd;
+	printf("call ARMul_InitSymTable,kernle filename is %s. \n",filename);
 
-	if (!filename) {
-		printf ("Can not get correct kernel filename!Maybe your skyeye.conf have something wrong!\n");
-		skyeye_exit (-1);
+	if(!filename){
+					printf("Can not get correct kernel filename!Maybe your skyeye.conf have something wrong!\n");
+					exit(-1);
 	}
-	/* <tktan> BUG200105221946 : get symbol from usrappl */
-	abfd = bfd_openr (filename, 0);
+  /* <tktan> BUG200105221946 : get symbol from usrappl */
+  abfd = bfd_openr (filename, 0);
 
-	/* <tktan> BUG200105221946 : get symbol from usrappl */
+  /* <tktan> BUG200105221946 : get symbol from usrappl */
 
-	/* <tktan> BUG200105221946 */
+  /* <tktan> BUG200105221946 */
 
-	if (!bfd_check_format (abfd, bfd_object)) {
-		printf ("Wrong format\n");
-		skyeye_exit (0);
-	}
+  if (!bfd_check_format(abfd, bfd_object)) {
+    printf("Wrong format\n") ;
+    exit(0);
+  }
 
-	storage_needed = bfd_get_symtab_upper_bound (abfd);
-	if (storage_needed < 0) {
-		printf ("FAIL\n");
-		skyeye_exit (0);
-	}
+  storage_needed = bfd_get_symtab_upper_bound(abfd);
+  if (storage_needed < 0){
+    printf("FAIL\n");
+    exit(0);
+  }
 
-	// <tktan> BUG200105221946 :symbol_table = (asymbol **) malloc (storage_needed);
-	symbol_table = (asymbol **) malloc (storage_needed);
+  // <tktan> BUG200105221946 :symbol_table = (asymbol **) malloc (storage_needed);
+  symbol_table = (asymbol **) malloc (storage_needed);
 
-	number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);
-	kernel_number = number_of_symbols;	/* <tktan> BUG200106022219 */
+  number_of_symbols =
+     bfd_canonicalize_symtab (abfd, symbol_table);
+  kernel_number = number_of_symbols; /* <tktan> BUG200106022219 */
 
-	if (number_of_symbols < 0) {
-		printf ("FAIL\n");
-		skyeye_exit (0);
-	}
+  if (number_of_symbols < 0){
+    printf("FAIL\n");
+    exit(0);
+  }
 
-	if (!hcreate (number_of_symbols << 1)) {
-		printf ("Not enough memory for hash table\n");
-		skyeye_exit (0);
-	}
-	for (i = 0; i < number_of_symbols; i++) {
-		symptr = symbol_table[i];
-		key = symptr->value + symptr->section->vma;	// adjust for section address
+  if (!hcreate(number_of_symbols << 1)) {
+    printf("Not enough memory for hash table\n");
+    exit(0);
+  }
+  for (i = 0; i < number_of_symbols; i++) {
+    symptr = symbol_table[i] ;
+    key = symptr->value + symptr->section->vma; // adjust for section address
 
-		if (((i < kernel_number) && (symbol_table[i]->flags == 0x01)) ||	// <tktan> BUG200105172154, BUG200106022219 
-		    ((i < kernel_number) && (symbol_table[i]->flags == 0x02)) ||	// <tktan> BUG200204051654
-		    (symbol_table[i]->flags & 0x10)) {	// Is a function symbol
-			// printf("%x %8x %s\n", symbol_table[i]->flags, key, symbol_table[i]->name);
+    if (((i<kernel_number) && (symbol_table[i]->flags == 0x01)) || // <tktan> BUG200105172154, BUG200106022219 
+	((i<kernel_number) && (symbol_table[i]->flags == 0x02)) || // <tktan> BUG200204051654
+	(symbol_table[i]->flags & 0x10)) { // Is a function symbol
+      // printf("%x %8x %s\n", symbol_table[i]->flags, key, symbol_table[i]->name);
 
-			// ***********************************************************
-			// This is converting the function symbol value to char string
-			// and use it as a key in the GNU hash table
-			// ********************************************************
-			newentry.key = (char *) malloc (9);
-			for (j = 0; j < 8; j++) {
-				newentry.key[j] =
-					itoa_tab[((key) >> (j << 2)) & 0xf];
-			}
-			newentry.key[8] = 0;
+      // ***********************************************************
+      // This is converting the function symbol value to char string
+      // and use it as a key in the GNU hash table
+      // ********************************************************
+      newentry.key = (char *) malloc(9);
+      for (j=0;j<8;j++) {
+        newentry.key[j] = itoa_tab[((key) >> (j << 2)) & 0xf] ;
+      }
+      newentry.key[8] = 0 ;
 
-			// *************************************************
-			// This is allocating memory for a struct funcsym
-			// *************************************************
-			symp = (SYM_FUNC *) malloc (sizeof (SYM_FUNC));
-			newentry.data = (char *) symp;
-			symp->name = (char *) symbol_table[i]->name;
-			symp->total_cycle = 0;
-			symp->total_energy = 0;
-			symp->instances = 0;
+      // *************************************************
+      // This is allocating memory for a struct funcsym
+      // *************************************************
+      symp = (SYM_FUNC *) malloc(sizeof(SYM_FUNC));
+      newentry.data = (char *) symp; 
+      symp->name = (char *) symbol_table[i]->name ;
+      symp->total_cycle = 0;
+      symp->total_energy = 0;
+      symp->instances = 0;
 
-			// ***********************************************
-			// Insert into hash table
-			// *******************************************
-			/* <tktan> BUG200106022219 */
-			oldentry = hsearch (newentry, FIND);
-			if (oldentry) {	// was entered
-				// printf("Duplicate Symbol: %x %s\n", key, symp->name);
-				oldentry->data = (char *) symp;
-			}
-			else if (!hsearch (newentry, ENTER)) {
-				printf ("Insufficient memory\n");
-				skyeye_exit (0);
-			}
-		}
-	}
+      // ***********************************************
+      // Insert into hash table
+      // *******************************************
+      /* <tktan> BUG200106022219 */
+      oldentry = hsearch(newentry, FIND) ;
+      if (oldentry) { // was entered
+        // printf("Duplicate Symbol: %x %s\n", key, symp->name);
+        oldentry->data = (char *) symp ;	
+      } else if (!hsearch(newentry, ENTER)) { 
+        printf("Insufficient memory\n");
+        exit(0) ;
+      }
+    }
+  }
 
-	return;
+  return;
 }
 #endif
 /***************************************************************
@@ -265,453 +254,426 @@
   If it exists, the corresponding pointer to the SYM_FUNC will
   be returned
 *************************************************************/
-SYM_FUNC *
-ARMul_GetSym (ARMword address)
+SYM_FUNC *ARMul_GetSym(ARMword address)
 {
-	int j;
-	ENTRY entry, *ep;
-	char text[9];
-	SYM_FUNC *symp;
+  int j ;
+  ENTRY entry, *ep;
+  char text[9] ;
+  SYM_FUNC *symp;
 
-	//printf("GetSym %x\n", address);
-	entry.key = text;
-	for (j = 0; j < 8; j++) {
-		entry.key[j] = itoa_tab[(address >> (j << 2)) & 0xf];
-	}
-	entry.key[8] = 0;
+  //printf("GetSym %x\n", address);
+  entry.key = text ;
+  for (j=0;j<8;j++) {
+    entry.key[j] = itoa_tab[(address >> (j << 2)) & 0xf] ;
+  }
+  entry.key[8] = 0 ;
 /*a bug need to fixed */
-	ep = hsearch (entry, FIND);
+  ep = hsearch(entry, FIND) ;
 
-	if (ep != 0) {
-		symp = (SYM_FUNC *) ep->data;
-		return (symp);
-	}
-	else
+  if (ep != 0) {
+    symp = (SYM_FUNC *) ep->data;
+    return(symp);
+  } else
 
-		return (0);
+    return(0);
 }
 
 /***************************************
 *  Function to initialize the energy profiling tree root
 ***************************************************/
-void
-ARMul_ProfInit (ARMul_State * state)
-{				/* <tktan> BUG200103311736 */
-	TASK_STACK *tsp;
-	printf ("call ARMul_ProfInit \n");
-	tsp = malloc (sizeof (TASK_STACK));
-	if (tsp <= 0) {
-		printf ("Memory allocation error in ARMul_ProfInit \n");
-		skyeye_exit (-1);
+void ARMul_ProfInit(ARMul_State *state) /* <tktan> BUG200103311736 */ 
+
+{
+  TASK_STACK *tsp;
+  printf("call ARMul_ProfInit \n");
+  tsp = malloc(sizeof(TASK_STACK));
+	if(tsp <= 0){
+	printf("Memory allocation error in ARMul_ProfInit \n");
+	exit(-1);
 	}
 
-	state->energy.cur_task = (void *) tsp;
-	tsp->task_id = 0xc00f0000;	// where the INIT_TASK reside 
-	memcpy (&(tsp->func_stack[0]), &init_node, sizeof (FUNC_NODE));
-	tsp->level = 0;
-	tsp->total_energy = 0;
-	tsp->total_cycle = 0;
-	tsp->next = tsp;
+  state->energy.cur_task = (void *) tsp;
+  //tsp->thread_id = 0xc00f0000; // where the INIT_TASK reside 
+  //tsp->thread_id = 0xc023bbe4;
+  tsp->thread_id = 0xc0236000;
+  memcpy(&(tsp->func_stack[0]), &init_node, sizeof(FUNC_NODE));
+  tsp->level=0;
+  tsp->total_energy=0;
+  tsp->total_cycle=0;
+  tsp->next = tsp;
 
-	return;
+  return;
 }
-
+  
 /****************************************
 * Function to create child function node
 ****************************************/
-FUNC_NODE *
-ARMul_CreateChild (ARMul_State * state)
+FUNC_NODE *ARMul_CreateChild(ARMul_State *state)
 {
-	TASK_STACK *tsp;
-	int level;
-	FUNC_NODE *fnp;
-
-	tsp = (TASK_STACK *) state->energy.cur_task;
-	(tsp->level)++;
-	level = tsp->level;
-	/* <tktan> BUG200105311233 */
-	if (level >= MAX_LEVEL) {
-		printf ("ARMul_CreateChild failed\n");
-		assert (0);
-	}
-
-	fnp = &(tsp->func_stack[level]);
+  TASK_STACK *tsp;
+  int level;
+  FUNC_NODE *fnp;
+  
+  tsp = (TASK_STACK *) state->energy.cur_task;
+  (tsp->level)++;
+  level = tsp->level;
+  /* <tktan> BUG200105311233 */
+  if (level >= MAX_LEVEL) {
+	printf("ARMul_CreateChild failed\n");
+	assert(0);
+  }
+  
+  fnp = &(tsp->func_stack[level]);
 //  printf("Create Child!\n ");
-	fnp->tenergy = tsp->total_energy;
-	fnp->tcycle = tsp->total_cycle;
-	return (fnp);
+  fnp->tenergy = tsp->total_energy;
+  fnp->tcycle = tsp->total_cycle;
+  return(fnp);
 }
 
 /******************************************
 * Function to destroy child nodes
 *****************************************/
-void
-ARMul_DestroyChild (ARMul_State * state)
+void ARMul_DestroyChild(ARMul_State *state)
 {
-	TASK_STACK *tsp;
-	int level;
-	long long fenergy;
-	long long fcycle;
-	FUNC_NODE *fnp;
+  TASK_STACK *tsp;
+  int level;
+  long long fenergy;
+  long long fcycle;
+  FUNC_NODE *fnp;
 
-	tsp = (TASK_STACK *) state->energy.cur_task;
-	level = tsp->level;
-	fnp = &(tsp->func_stack[level]);
-	// <tktan> BUG200105222137 fenergy = state->t_energy - fnp->tenergy;
-	fenergy = tsp->total_energy - fnp->tenergy;
-	fcycle = tsp->total_cycle - fnp->tcycle;
+  tsp = (TASK_STACK *) state->energy.cur_task;
+  level = tsp->level;
+  fnp = &(tsp->func_stack[level]);
+  // <tktan> BUG200105222137 fenergy = state->t_energy - fnp->tenergy;
+  fenergy = tsp->total_energy - fnp->tenergy;
+  fcycle = tsp->total_cycle - fnp->tcycle;
 
-	/* <tktan> BUG200105181702 */
-	if ((state->energy.enable_func_energy)
-	    && !(strcmp (state->energy.func_energy, fnp->func_symbol->name))) {
-		printf ("energy_report %s %f\n", fnp->func_symbol->name,
-			fenergy);
-	}
-
-	/* <tktan> BUG200104101936 */
-	if (state->energy.energy_prof) {
-		fnp->func_symbol->total_energy += fenergy;
-		fnp->func_symbol->total_cycle += fcycle;
-		(fnp->func_symbol->instances)++;
-	}
-	//printf("Destroy child,name %s \n",fnp->func_symbol->name);
-	tsp->level = level - 1;
-	return;
+  /* <tktan> BUG200105181702 */
+  if ((state->energy.enable_func_energy) && !(strcmp(state->energy.func_energy, fnp->func_symbol->name)))  {
+    printf("energy_report %s %f\n", fnp->func_symbol->name, fenergy);
+  }
+ 
+  /* <tktan> BUG200104101936 */
+  if (state->energy.energy_prof) {
+    fnp->func_symbol->total_energy += fenergy;
+    fnp->func_symbol->total_cycle += fcycle;
+    (fnp->func_symbol->instances)++;
+  }
+  //printf("Destroy child,name %s \n",fnp->func_symbol->name);
+  tsp->level = level - 1;
+  return;
 }
 
 
 /************************************************
   Function to check the different kind of branch 
 ************************************************/
-void
-ARMul_CallCheck (ARMul_State * state, ARMword cur_pc, ARMword to_pc,
-		 ARMword instr)
+void ARMul_CallCheck(ARMul_State *state, ARMword cur_pc, ARMword to_pc, ARMword instr)
 {
-	FUNC_NODE *child_node;
-	TASK_STACK *tsp;
-	SYM_FUNC *symp;
-	int i, bt, level;
-	ARMword new_task_id, fp_value;
+  FUNC_NODE *child_node ;
+  TASK_STACK *tsp;
+  SYM_FUNC *symp;
+  int i, bt, level;
+  ARMword new_thread_id, fp_value;
 
-	tsp = (TASK_STACK *) state->energy.cur_task;
-	level = tsp->level;
-	fp_value = state->Reg[11];	// BUG200311301153
+  tsp  = (TASK_STACK *) state->energy.cur_task;
+  level = tsp->level;
+  fp_value = state->Reg[11]; // BUG200311301153
 #if 0
-	if (debug != tsp->task_id || !debug) {
-		printf ("cur_task is changed! %x \n", tsp->task_id);
-		debug = tsp->task_id;
-	}
+if(debug != tsp->thread_id || !debug){
+	printf("cur_task is changed! %x \n",tsp->thread_id);
+	debug = tsp->thread_id;
+}
 #endif
 
-	/* <tktan> BUG200105311233 */
-	if (level >= MAX_LEVEL) {
-		printf ("ARMul_CallCheck failed\n");
-		printf ("level %d \n", level);
-		//exit(-1);
-	}
-	// First check if it is normal return
-	if (to_pc == (tsp->func_stack[level].ret_addr + 4)) {
-		if (state->energy.func_display & state->energy.func_disp_start) {	/* <tktan> BUG200104191428 */
-			//if(1){
-			printf ("[%x:%d:%x] Function return %s (%x)--> %s (%x)\n", tsp->task_id, level, fp_value, tsp->func_stack[level].func_symbol->name, cur_pc, tsp->func_stack[level - 1].func_symbol->name, to_pc);
-		}
+  /* <tktan> BUG200105311233 */
+  if (level >= MAX_LEVEL) {
+        printf("ARMul_CallCheck failed\n");
+	printf("level %d \n",level);
+        //exit(-1);
+  }
+  // First check if it is normal return
+  if (to_pc == (tsp->func_stack[level].ret_addr+4)) {
+    if (state->energy.func_display & state->energy.func_disp_start) { /* <tktan> BUG200104191428 */
+	//if(1){
+      printf("[%x:%d:%x] Function return %s (%x)--> %s (%x)\n", tsp->thread_id, level, fp_value, \
+	tsp->func_stack[level].func_symbol->name, cur_pc, tsp->func_stack[level-1].func_symbol->name, to_pc);
+    }
 
-		/* <tktan> BUG200104101736 */
-		ARMul_DestroyChild (state);
+    /* <tktan> BUG200104101736 */
+    ARMul_DestroyChild(state);
 
-		return;
-	}
-	// Check if it is a trap return
-	// a trap return is one that jump to a saved interrupted address, saved
-	// in .ret_addr
-	bt = 0;
-	while ((level - bt >= 0) && (bt <= 3)) {
-		if (to_pc == tsp->func_stack[level - bt].ret_addr) {
-			if (state->energy.func_display & state->energy.func_disp_start) {	/* <tktan> BUG200104191428 */
-				printf ("[%x:%d:%x] Trap Return -> %s\n",
-					tsp->task_id, level, fp_value,
-					tsp->func_stack[level - bt -
-							1].func_symbol->name);
-			}
+    return;
+  }
+  // Check if it is a trap return
+  // a trap return is one that jump to a saved interrupted address, saved
+  // in .ret_addr
+  bt = 0;
+  while ((level - bt >= 0) && (bt <= 3)) {
+    if (to_pc == tsp->func_stack[level-bt].ret_addr) {
+      if (state->energy.func_display & state->energy.func_disp_start) { /* <tktan> BUG200104191428 */
+        printf("[%x:%d:%x] Trap Return -> %s\n", tsp->thread_id, level, fp_value, \
+	  tsp->func_stack[level-bt-1].func_symbol->name);
+      }
 
-			/* <tktan> BUG200104101736 */
-			for (i = 0; i <= bt; i++) {
-				ARMul_DestroyChild (state);
-			}
+      /* <tktan> BUG200104101736 */
+      for (i=0;i<=bt;i++) {
+        ARMul_DestroyChild(state);
+      }
 
-			return;
-		}
-		bt++;
-	}
+      return;
+    }
+    bt++;
+  }
 
-	// BUG200311212039
-	// check if it is a recursive call, or I was missing some returns through
-	// abnormal jumps
-	bt = 0;
-	while ((level - bt >= 0) && (bt <= 2)) {
-		if (to_pc == tsp->func_stack[level - bt].func_start_addr) {
-			if (state->energy.func_display & state->energy.func_disp_start) {	/* <tktan> BUG200104191428 */
-				printf ("[%x:%d:%x] Function %s ended\n",
-					tsp->task_id, level, fp_value,
-					tsp->func_stack[level -
-							bt].func_symbol->
-					name);
-			}
+  // BUG200311212039
+  // check if it is a recursive call, or I was missing some returns through
+  // abnormal jumps
+  bt = 0;
+  while ((level - bt >=0) && (bt <=2)) {
+    if (to_pc == tsp->func_stack[level-bt].func_start_addr) {
+      if (state->energy.func_display & state->energy.func_disp_start) { /* <tktan> BUG200104191428 */
+        printf("[%x:%d:%x] Function %s ended\n", tsp->thread_id, level, fp_value, \
+          tsp->func_stack[level-bt].func_symbol->name);
+      }
+			
+      /* <tktan> BUG200104101736 */
+      for (i=0;i<=bt;i++) {
+        ARMul_DestroyChild(state);
+      }
 
-			/* <tktan> BUG200104101736 */
-			for (i = 0; i <= bt; i++) {
-				ARMul_DestroyChild (state);
-			}
+    }
+    bt++;
+  }
+  tsp  = (TASK_STACK *) state->energy.cur_task;
+  level = tsp->level;
+ 
+  // check if it is a trap
+  //if (!(to_pc & 0xffffffe0) && (state->Reg[14] == (cur_pc+4))) { // check for pc from 0x0 - 0x1f
+  // BUG200311302126: Reg[14]_abt is cur_pc+8 for DataAbort,
+  // but cur_pc+4 for other exception. So, better not check it 
+  if (!(to_pc & 0xffffffe0)) { // check for pc from 0x0 - 0x1f
+    child_node = ARMul_CreateChild(state); /* <tktan> BUG200104101736 */
+    child_node->ret_addr = cur_pc;
+    child_node->func_start_addr = to_pc;
+    child_node->func_symbol = &trap_sym ;
 
-		}
-		bt++;
-	}
-	tsp = (TASK_STACK *) state->energy.cur_task;
-	level = tsp->level;
+    if (state->energy.func_display & state->energy.func_disp_start) { /* <tktan> BUG200104191428 */
+      printf("[%x:%d:%x] Function %s(%x) --> Trap %x\n", tsp->thread_id, level, fp_value, \
+	tsp->func_stack[level].func_symbol->name, cur_pc, to_pc);
+    }
+    return;
+  }
 
-	// check if it is a trap
-	//if (!(to_pc & 0xffffffe0) && (state->Reg[14] == (cur_pc+4))) { // check for pc from 0x0 - 0x1f
-	// BUG200311302126: Reg[14]_abt is cur_pc+8 for DataAbort,
-	// but cur_pc+4 for other exception. So, better not check it 
-	if (!(to_pc & 0xffffffe0)) {	// check for pc from 0x0 - 0x1f
-		child_node = ARMul_CreateChild (state);	/* <tktan> BUG200104101736 */
-		child_node->ret_addr = cur_pc;
-		child_node->func_start_addr = to_pc;
-		child_node->func_symbol = &trap_sym;
+  // Check if it is a function call
 
-		if (state->energy.func_display & state->energy.func_disp_start) {	/* <tktan> BUG200104191428 */
-			printf ("[%x:%d:%x] Function %s(%x) --> Trap %x\n",
-				tsp->task_id, level, fp_value,
-				tsp->func_stack[level].func_symbol->name,
-				cur_pc, to_pc);
-		}
-		return;
-	}
+  if ((state->Reg[14] == (cur_pc+4)) || /* <tktan> BUG200105172030 */
+	(BITS(20,27) & 0xf0) == 0xb0) { /* <tktan> BUG200104012116 */
 
-	// Check if it is a function call
+    symp = ARMul_GetSym(to_pc) ;
+    if (symp) { 
+      // it is an entry into a function
+      child_node = ARMul_CreateChild(state); /* <tktan> BUG2001040101736 */
+      child_node->ret_addr = cur_pc;
+      child_node->func_start_addr = to_pc;
+      child_node->func_symbol = symp;
 
-	if ((state->Reg[14] == (cur_pc + 4)) ||	/* <tktan> BUG200105172030 */
-	    (BITS (20, 27) & 0xf0) == 0xb0) {	/* <tktan> BUG200104012116 */
 
-		symp = ARMul_GetSym (to_pc);
-		if (symp) {
-			// it is an entry into a function
-			child_node = ARMul_CreateChild (state);	/* <tktan> BUG2001040101736 */
-			child_node->ret_addr = cur_pc;
-			child_node->func_start_addr = to_pc;
-			child_node->func_symbol = symp;
+      /* <tktan> BUG200105211055 : perform task switch */
+      if (!strcmp(symp->name, "__switch_to")) { // BUG200204021340
+				ARMul_TaskSwitch(state);
+      }
+      if (!strcmp(symp->name, "copy_thread")) {
+				new_thread_id = ARMul_TaskCreate(state);
+			}	
+    }  
 
-
-			/* <tktan> BUG200105211055 : perform task switch */
-			if (!strcmp (symp->name, "__switch_to")) {	// BUG200204021340
-				ARMul_TaskSwitch (state);
-			}
-			if (!strcmp (symp->name, "copy_thread")) {
-				new_task_id = ARMul_TaskCreate (state);
-			}
-		}
-
-	}			/* <tktan> BUG200104012116 */
-	// Just a normal branch, maybe
-	return;
+  } /* <tktan> BUG200104012116 */
+  // Just a normal branch, maybe
+  return;
 }
 
 /* <tktan> BUG200105211055 : perform task switch */
-void
-ARMul_TaskSwitch (ARMul_State * state)
+void ARMul_TaskSwitch(ARMul_State *state)
 {
-	TASK_STACK *ctsp, *oldtsp, *newtsp;
-	//ARMword to_thread_id;
-	ARMword to_task_id;
-	int done = 0;
+  TASK_STACK *ctsp, *oldtsp, *newtsp;
+  ARMword to_thread_id;
+  //ARMword to_thread_id;
+  int done=0;
 
-	//to_thread_id = state->Reg[2] ; // r1, the to_task task structure
-	to_task_id = state->Reg[7];
-	oldtsp = (TASK_STACK *) state->energy.cur_task;
-	//printf("cur_task id %x \n",state->Reg[0]);
-	oldtsp->task_id = state->Reg[0];	/* <tktan> BUG200106051701 */
-	//printf("Task ThreadInfo Switch from %x to %x\n", oldtsp->thread_id, to_thread_id);
-	//printf("task switch from %x to %x \n",oldtsp->task_id,to_task_id);
-	ctsp = oldtsp->next;
-	while (!done && (ctsp != oldtsp)) {
-		if (ctsp->task_id == to_task_id) {
-			done = 1;
-			newtsp = ctsp;
-		}
-//      printf("ctsp taskid=%x,next task_id=%x \n",ctsp->task_id,ctsp->next->task_id);
-		ctsp = ctsp->next;
-	}
-
-	if (done)
-		state->energy.cur_task = (void *) newtsp;
-	else {
-		printf ("Error : Can not find task stack\n");
-		//print_allTask(state);
-		skyeye_exit (-1);
-	}
+  to_thread_id = state->Reg[2] ; // r1, the to_task task structure
+  //to_thread_id = state->Reg[7];
+  oldtsp = (TASK_STACK *) state->energy.cur_task;
+  //printf("cur_task id %x \n",state->Reg[0]);
+  oldtsp->thread_id = state->Reg[1]; /* <tktan> BUG200106051701 */
+  //printf("Task ThreadInfo Switch from %x to %x\n", oldtsp->thread_id, to_thread_id);
+  //printf("task switch from %x to %x \n",oldtsp->thread_id,to_thread_id);
+  ctsp = oldtsp->next;
+  while (!done && (ctsp != oldtsp)) {
+    if (ctsp->thread_id == to_thread_id) {
+      done = 1;
+      newtsp = ctsp;
+    }
+    //printf("ctsp taskid=%x,next thread_id=%x \n",ctsp->thread_id,ctsp->next->thread_id);
+    ctsp = ctsp->next;
+  }
+ 
+  if (done) 
+    state->energy.cur_task = (void *) newtsp;
+  else {
+    printf("Error : Can not find task stack\n");
+	  //print_allTask(state);
+    exit(-1);
+  }
 }
-void
-print_allTask (ARMul_State * state)
-{
+void print_allTask(ARMul_State *state){
 	TASK_STACK *ctsp, *oldtsp, *newtsp;
-	ARMword to_task_id;
+  ARMword to_thread_id;
 
-	oldtsp = (TASK_STACK *) state->energy.cur_task;
-	ctsp = oldtsp;
+  oldtsp = (TASK_STACK *) state->energy.cur_task;
+  ctsp = oldtsp;
 #if 0
-	printf ("Begin to print all task...\n");
-	do {
-		printf ("ctsp taskid=%x,next task_id=%x \n", ctsp->task_id,
-			ctsp->next->task_id);
-		ctsp = ctsp->next;
-	}
-	while (ctsp != oldtsp);
-	printf ("End to print....\n");
+printf("Begin to print all task...\n");
+do{
+	printf("ctsp taskid=%x,next thread_id=%x \n",ctsp->thread_id,ctsp->next->thread_id);
+	ctsp = ctsp->next;
+}while(ctsp != oldtsp);
+printf("End to print....\n");
 #endif
 }
-
-/* <tktan> BUG200105211055 : create new task stack */
-ARMword
-ARMul_TaskCreate (ARMul_State * state)
+/* <tktan> BUG200105211055 : create new task stack */ 
+ARMword ARMul_TaskCreate(ARMul_State *state)
 {
-	TASK_STACK *oldtsp, *newtsp, *oldnext;
-	ARMword to_task_id;
-	int i;
+  TASK_STACK *oldtsp, *newtsp, *oldnext;
+  ARMword to_thread_id;
+  int i;
 
-	to_task_id = state->Reg[3];	// r3, the to_task task structure
-	if (to_task_id == 0x00000000) {	// BUG200204081717
-		to_task_id = state->Reg[5];	// r5 store the to_task task structure
-	}
+  /* get thread_id according to copy_thread function in arch/arm/kernel/process.c */
+  unsigned long task_p = mem_read_word(state, state->Reg[13]);
+  to_thread_id = mem_read_word(state, (task_p + 4));
+  //to_thread_id = state->Reg[3] ; // r3, the to_task task structure
+  if (to_thread_id == 0x00000000) { // BUG200204081717
+    to_thread_id = state->Reg[5] ; // r5 store the to_task task structure
+  }
 
-	oldtsp = (TASK_STACK *) state->energy.cur_task;
+  oldtsp = (TASK_STACK *) state->energy.cur_task;
 
-	newtsp = malloc (sizeof (TASK_STACK));
-	memcpy (newtsp, oldtsp, sizeof (TASK_STACK));
-	newtsp->task_id = to_task_id;
-	newtsp->level -= 2;	// point to the SWI level
+  newtsp = malloc(sizeof(TASK_STACK));
+  memcpy(newtsp, oldtsp, sizeof(TASK_STACK));
+  newtsp->thread_id = to_thread_id;
+  newtsp->level -= 2; // point to the SWI level
+  
+  /* <tktan> BUG200105222137 */
+  newtsp->total_cycle = 0;
+  // newtsp->total_energy = 0.0; BUG200106142205, possible problem
+  newtsp->total_energy = 0;
+  for (i=0;i<=newtsp->level;i++) {
+    newtsp->func_stack[i].tcycle = 0;
+    newtsp->func_stack[i].tenergy = 0;
+  }
 
-	/* <tktan> BUG200105222137 */
-	newtsp->total_cycle = 0;
-	// newtsp->total_energy = 0.0; BUG200106142205, possible problem
-	newtsp->total_energy = 0;
-	for (i = 0; i <= newtsp->level; i++) {
-		newtsp->func_stack[i].tcycle = 0;
-		newtsp->func_stack[i].tenergy = 0;
-	}
-
-	/* put newtsp after oldtsp */
-	oldnext = oldtsp->next;
-	oldtsp->next = newtsp;
-	newtsp->next = oldnext;
-	//printf("Create a new task,task_id=%x \n",to_task_id);
+  /* put newtsp after oldtsp */
+  oldnext = oldtsp->next;
+  oldtsp->next = newtsp;
+  newtsp->next = oldnext;
+// printf("Create a new task,thread_id=%x \n",to_thread_id);
 //print_allTask(state);
-	return (to_task_id);
+  return(to_thread_id);
 }
 
 /********************************************
  *  Function to report energy tree
  *******************************************/
-void
-ARMul_ReportEnergy (ARMul_State * state, FILE * pf)
+void ARMul_ReportEnergy(ARMul_State *state, FILE* pf)
 {
-	int i, j;
-	ENTRY entry, *ep;
-	char text[9];
-	SYM_FUNC *symp;
-	asymbol *symptr;
-	ARMword address;
-	TASK_STACK *ctsp, *oldtsp;
-	float energy;
+  int i, j;
+  ENTRY entry, *ep;
+  char text[9];
+  SYM_FUNC *symp;
+  asymbol *symptr;
+  ARMword address;
+  TASK_STACK *ctsp, *oldtsp;
+  float energy;
 
-	ARMul_Consolidate (state);	// <tktan> BUG200105222137 
+  ARMul_Consolidate(state); // <tktan> BUG200105222137 
 
-	for (i = 0; i < number_of_symbols; i++) {
-		symptr = symbol_table[i];
-		address = symptr->value + symptr->section->vma;	// adjust for section address
+  for(i=0;i<number_of_symbols;i++) {
+    symptr = symbol_table[i] ;
+    address = symptr->value + symptr->section->vma; // adjust for section address
 
-		if (((i < kernel_number) && (symbol_table[i]->flags == 0x01)) ||	// <tktan> BUG200105172154, BUG200106022219
-		    ((i < kernel_number) && (symbol_table[i]->flags == 0x02)) ||	// <tktan> BUG200204051654, BUG200311211406
-		    (symbol_table[i]->flags & 0x10)) {	// Is a function symbol
+    if (((i<kernel_number) && (symbol_table[i]->flags == 0x01)) || // <tktan> BUG200105172154, BUG200106022219
+	((i<kernel_number) && (symbol_table[i]->flags == 0x02)) || // <tktan> BUG200204051654, BUG200311211406
+	(symbol_table[i]->flags & 0x10)) { // Is a function symbol
 
-			// ***********************************************************
-			// This is converting the function symbol value to char string
-			// and use it as a key in the GNU hash table
-			// ********************************************************
-			entry.key = text;
-			for (j = 0; j < 8; j++) {
-				entry.key[j] =
-					itoa_tab[(address >> (j << 2)) & 0xf];
-			}
-			entry.key[8] = 0;
+      // ***********************************************************
+      // This is converting the function symbol value to char string
+      // and use it as a key in the GNU hash table
+      // ********************************************************
+      entry.key = text ;
+      for (j=0;j<8;j++) {
+        entry.key[j] = itoa_tab[(address >> (j << 2)) & 0xf] ;
+      }
+      entry.key[8] = 0 ;
 
-			ep = hsearch (entry, FIND);
-			if (ep != 0) {
-				symp = (SYM_FUNC *) ep->data;
-				/*modified by ksh for evaluate the usrappl program only */
-				/*
-				   if(strncmp(symp->name,"usrappl",7) != 0){
-				   continue;
-				   }
-				 */
-				if (symp->instances > 0) {	// only show if executed
-					energy = symp->total_energy;
-					fprintf (pf, "%s %d %lld %f\n",
-						 symp->name, symp->instances,
-						 symp->total_cycle, energy);
-				}
-			}
+      ep = hsearch(entry, FIND) ;
+      if (ep != 0) {
+        symp = (SYM_FUNC *) ep->data;
+	/*modified by ksh for evaluate the usrappl program only*/
+		/*
+		if(strncmp(symp->name,"usrappl",7) != 0){
+		continue;
 		}
+		*/
+        if (symp->instances > 0) {// only show if executed
+		energy = symp->total_energy;
+	  	fprintf(pf,"%s %d %lld %f\n", symp->name, symp->instances, symp->total_cycle, energy);
 	}
+      }
+    }
+  }
 
-	/* <tktan> BUG200105222137 : print out task energy */
-	oldtsp = (TASK_STACK *) state->energy.cur_task;
-	ctsp = oldtsp;
-	do {
-		energy = ctsp->total_energy;
-		fprintf (pf, "Task[%x] %lld %f\n", ctsp->task_id,
-			 ctsp->total_cycle, energy);
-		ctsp = ctsp->next;
-	}
-	while (ctsp != oldtsp);
+  /* <tktan> BUG200105222137 : print out task energy */
+  oldtsp = (TASK_STACK *) state->energy.cur_task;
+  ctsp = oldtsp;
+  fprintf(pf, "TASK_ID   Cycles   Energy\n");
+  do {
+    energy = ctsp->total_energy;
+    fprintf(pf,"Task[%x] %lld %f\n", ctsp->thread_id, ctsp->total_cycle, energy);
+    ctsp = ctsp->next;
+  } while (ctsp != oldtsp);
 }
 
 /* <tktan> BUG200105222137 : consolidate unfinished function energy */
-void
-ARMul_Consolidate (ARMul_State * state)
+void ARMul_Consolidate(ARMul_State *state)
 {
-	long long fenergy;	// <tktan> BUG200106142205
-	long long fcycle;	// <tktan> BUG200106142205
-	FUNC_NODE *fnp;
-	TASK_STACK *ctsp, *oldtsp;
-	int i;
-	double energy;
+  long long fenergy; // <tktan> BUG200106142205
+  long long fcycle; // <tktan> BUG200106142205
+  FUNC_NODE *fnp;
+  TASK_STACK *ctsp, *oldtsp;
+  int i;
+  double energy;
 
-	/* <tktan> BUG200105222137 : report energy for tasks */
-	/* <tktan> BUG200106041235 : use do instead of while */
-	oldtsp = (TASK_STACK *) state->energy.cur_task;
-	ctsp = oldtsp;
-	do {
-		for (i = ctsp->level; i >= 0; i--) {
-			fnp = &(ctsp->func_stack[i]);
-			fenergy = ctsp->total_energy - fnp->tenergy;
-			fcycle = ctsp->total_cycle - fnp->tcycle;
+  /* <tktan> BUG200105222137 : report energy for tasks */
+  /* <tktan> BUG200106041235 : use do instead of while */
+  oldtsp = (TASK_STACK *) state->energy.cur_task;
+  ctsp = oldtsp;
+  do {
+    for (i=ctsp->level;i>=0;i--) {
+      fnp = &(ctsp->func_stack[i]);
+      fenergy = ctsp->total_energy - fnp->tenergy;
+      fcycle = ctsp->total_cycle - fnp->tcycle;
 
-			/* copied from <tktan> BUG200105181702 */
-			if ((state->energy.enable_func_energy)
-			    &&
-			    !(strcmp
-			      (state->energy.func_energy,
-			       fnp->func_symbol->name))) {
-				//energy = I2ENERGY(fenergy);
-				//fprintf(pf,"energy_report %s %f\n", fnp->func_symbol->name, energy);
-			}
+      /* copied from <tktan> BUG200105181702 */
+      if ((state->energy.enable_func_energy) && !(strcmp(state->energy.func_energy, fnp->func_symbol->name)))  {
+	//energy = I2ENERGY(fenergy);
+        //fprintf(pf,"energy_report %s %f\n", fnp->func_symbol->name, energy);
+      }
 
-			/* copied from <tktan> BUG200104101936 */
-			fnp->func_symbol->total_energy += fenergy;
-			fnp->func_symbol->total_cycle += fcycle;
-			(fnp->func_symbol->instances)++;
-		}
-		ctsp = ctsp->next;
-	}
-	while (ctsp != oldtsp);
+      /* copied from <tktan> BUG200104101936 */
+      fnp->func_symbol->total_energy += fenergy;
+      fnp->func_symbol->total_cycle += fcycle;
+      (fnp->func_symbol->instances)++;
+    }
+    ctsp = ctsp->next;
+  } while (ctsp != oldtsp);
 }
Index: arch/arm/common/armsym.h
===================================================================
--- arch/arm/common/armsym.h	(revision 301)
+++ arch/arm/common/armsym.h	(working copy)
@@ -20,43 +20,41 @@
 
 #include "armdefs.h"
 
-struct sym_func
-{
-	char *name;
-	long long total_energy;	// for all instances
-	long long total_cycle;	// for all instances
-	int instances;		// number of instances
+struct sym_func {
+  char *name;
+  long long total_energy; // for all instances
+  long long total_cycle; // for all instances
+  int instances; // number of instances
 };
 
 typedef struct sym_func SYM_FUNC;
 
-struct sym_funcinst
-{
-	/* Function Info */
-	SYM_FUNC *func_symbol;
-	ARMword func_start_addr;	// the address at which this function starts
-	ARMword ret_addr;	// the  PC at which we make sub-routine call 
+struct sym_funcinst {
+  /* Function Info */
+  SYM_FUNC *func_symbol;
+  ARMword func_start_addr; // the address at which this function starts
+  ARMword ret_addr; // the  PC at which we make sub-routine call 
 
-	/* Profiling Data */
-	float tenergy;
-	long long tcycle;
+  /* Profiling Data */
+  float tenergy;
+  long long tcycle;
 };
 
 #define MAX_LEVEL 1024
 
-struct sym_taskinst
-{
-	ARMword task_id;	// Actually is the pointer to Linux struct task_struct 
-	/* Task call stack */
-	struct sym_funcinst func_stack[MAX_LEVEL];
-	int level;
+struct sym_taskinst {
+  //ARMword task_id; // Actually is the pointer to Linux struct task_struct 
+  ARMword thread_id; // Actually is the pointer to Linux struct thread_info
+  /* Task call stack */
+  struct sym_funcinst func_stack[MAX_LEVEL];
+  int level;
 
-	/* Profiling Data */
-	float total_energy;
-	long long total_cycle;
+  /* Profiling Data */
+  float total_energy;
+  long long total_cycle;
 
-	/* link data */
-	struct sym_taskinst *next;
+  /* link data */
+  struct sym_taskinst *next;
 };
 
 typedef struct sym_funcinst FUNC_NODE;
@@ -66,14 +64,14 @@
   Function declaration
 ******************************************************/
 //void ARMul_InitSymTable(bfd *abfd);
-SYM_FUNC *ARMul_GetSym (ARMword address);
-void ARMul_ProfInit (ARMul_State * state);
-FUNC_NODE *ARMul_CreateChild (ARMul_State * state);
-void ARMul_DestroyChild (ARMul_State * state);
-void ARMul_CallCheck (ARMul_State * state, ARMword cur_pc, ARMword to_pc,
-		      ARMword instr);
-void ARMul_TaskSwitch (ARMul_State * state);
-ARMword ARMul_TaskCreate (ARMul_State * state);
-void ARMul_ReportEnergy (ARMul_State * state, FILE * pf);
-void ARMul_Consolidate (ARMul_State * state);
+SYM_FUNC *ARMul_GetSym(ARMword address);
+void ARMul_ProfInit(ARMul_State *state);
+FUNC_NODE *ARMul_CreateChild(ARMul_State *state);
+void ARMul_DestroyChild(ARMul_State *state);
+void ARMul_CallCheck(ARMul_State *state, ARMword cur_pc, ARMword to_pc, ARMword instr);
+void ARMul_TaskSwitch(ARMul_State *state);
+ARMword ARMul_TaskCreate(ARMul_State *state);
+void ARMul_ReportEnergy(ARMul_State *state, FILE* pf);
+void ARMul_Consolidate(ARMul_State *state);
 #endif
+
Index: arch/arm/common/armmem.c
===================================================================
--- arch/arm/common/armmem.c	(revision 301)
+++ arch/arm/common/armmem.c	(working copy)
@@ -284,7 +284,7 @@
 		fprintf(stderr, "SKYEYE:NumInstrs %llu, mem_write_byte addr = %x no bank\n",state->NumInstrs, addr);
 		//chy 2003-09-03
 		//SKYEYE_OUTREGS(stderr);
-		skyeye_exit(-1);
+		//skyeye_exit(-1);
 	}
 }
 void
Index: arch/arm/common/armemu.c
===================================================================
--- arch/arm/common/armemu.c	(revision 301)
+++ arch/arm/common/armemu.c	(working copy)
@@ -598,23 +598,25 @@
 		if (state->NresetSig == LOW) {
 			ARMul_Abort (state, ARMul_ResetV);
 
-			/*added energy_prof statement by ksh in 2004-11-26 */
-			//chy 2005-07-28 for standalone
-			//ARMul_do_energy(state,instr,pc);
+			/* Energy profiling  */
+			if (skyeye_config.energy.energy_prof)
+				ARMul_do_energy(state,instr,pc);
 			break;
 		}
 		else if (!state->NfiqSig && !FFLAG) {
 			ARMul_Abort (state, ARMul_FIQV);
-			/*added energy_prof statement by ksh in 2004-11-26 */
-			//chy 2005-07-28 for standalone
-			//ARMul_do_energy(state,instr,pc);
+
+			/* Add energy profiling */
+			if(skyeye_config.energy.energy_prof)
+				ARMul_do_energy(state,instr,pc);
 			break;
 		}
 		else if (!state->NirqSig && !IFLAG) {
 			ARMul_Abort (state, ARMul_IRQV);
-			/*added energy_prof statement by ksh in 2004-11-26 */
-			//chy 2005-07-28 for standalone
-			//ARMul_do_energy(state,instr,pc);
+
+			/* Add energy profiling */
+			if(skyeye_config.energy.energy_prof)
+				ARMul_do_energy(state,instr,pc);
 			break;
 		}
 
@@ -4080,9 +4082,9 @@
 		}
 #endif /* NEED_UI_LOOP_HOOK */
 
-		/*added energy_prof statement by ksh in 2004-11-26 */
-		//chy 2005-07-28 for standalone
-		//ARMul_do_energy(state,instr,pc);
+		/* Energy profiling */
+		if(skyeye_config.energy.energy_prof)
+			ARMul_do_energy(state,instr,pc);
 //teawater add for record reg value to ./reg.txt 2005.07.10---------------------
 		if (state->tea_break_ok && pc == state->tea_break_addr) {
 			ARMul_Debug (state, 0, 0);
Index: arch/arm/common/armengr.c
===================================================================
--- arch/arm/common/armengr.c	(revision 301)
+++ arch/arm/common/armengr.c	(working copy)
@@ -107,7 +107,6 @@
 	float Core_freq;
 	float Vdd;
 	unsigned int cccr = state->energy.cccr;
-//      printf("before calculate:cccr=0x%x,cccr&0x0=0x%x \n",cccr,cccr&0x0);
 	switch ((cccr >> 7) & 0x7) {
 	case 2:
 		N = 1;
@@ -126,7 +125,6 @@
 		N = 1;
 		break;
 	}
-//printf("before calculate:cccr=0x%x,cccr&0x0=0x%x \n",cccr,cccr&0x0);
 	switch ((cccr >> 5) & 0x3) {
 	case 1:
 		M = 1;
Index: arch/arm/common/arm_arch_interface.c
===================================================================
--- arch/arm/common/arm_arch_interface.c	(revision 301)
+++ arch/arm/common/arm_arch_interface.c	(working copy)
@@ -18,11 +18,6 @@
 ARMul_ConsolePrint (ARMul_State * state, const char *format, ...)
 {
 }
-void
-ARMul_CallCheck (ARMul_State * state, ARMword cur_pc, ARMword to_pc,
-		 ARMword instr)
-{
-}
 
 static void
 base_termios_exit (void)
@@ -78,6 +73,15 @@
 	//chy 2005-08-01 commit and disable ksh's energy estimantion, will be recover in the future
 	/*added by ksh for energy estimation,in 2004-11-26 */
 	state->energy.energy_prof = skyeye_config.energy.energy_prof;
+	ARMul_EnergyInit(state);
+	ARMul_ProfInit(state);
+	if(!state->energy.outfile)
+		if(!(state->energy.outfile = fopen(skyeye_config.energy.logfile, "w"))){
+			fprintf(stderr, "Error when open energy log file %s\n", skyeye_config.energy.logfile);
+			skyeye_exit(-1);
+		}
+		else
+			printf("Open energy log file %s for profiling.\n", skyeye_config.energy.logfile);
 	/*mach init */
 	skyeye_config.mach->mach_init (state, skyeye_config.mach);
 }
Index: Makefile
===================================================================
--- Makefile	(revision 301)
+++ Makefile	(working copy)
@@ -191,7 +191,7 @@
 			 $(DEVICE_CFLAGS) $(UTILS_CFLAGS) -g -O
 endif
 
-SIM_ARM_OBJS =  binary/armcopro.o binary/armemu26.o binary/armemu32.o binary/arminit.o  binary/armsupp.o binary/armos.o binary/thumbemu.o binary/armvirt.o  binary/armmmu.o binary/armmem.o binary/armio.o  binary/arm_arch_interface.o
+SIM_ARM_OBJS =  binary/armcopro.o binary/armemu26.o binary/armemu32.o binary/arminit.o  binary/armsupp.o binary/armos.o binary/thumbemu.o binary/armvirt.o  binary/armmmu.o binary/armmem.o binary/armio.o  binary/arm_arch_interface.o binary/armengr.o binary/armsym.o
 BFIN_DBCT_OBJS = binary/bfin_tb.o binary/dbct_step.o binary/bfin2x86_load_store.o binary/bfin2x86_move.o binary/bfin2x86_arith.o
 BFIN_COMMON_OBJS = binary/bfin_arch_interface.o binary/iomem.o binary/bfin-dis.o
 BFIN_MACH_OBJS = binary/bf533_io.o binary/bf537_io.o
@@ -554,6 +554,10 @@
 	$(CC) -c $< -o $@ $(ALL_CFLAGS)
 binary/arm_arch_interface.o:	$(ARM_COMMON_PATH)/arm_arch_interface.c
 	$(CC) -c $< -o $@ $(ALL_CFLAGS)
+binary/armengr.o:	$(ARM_COMMON_PATH)/armengr.c
+	$(CC) -c $< -o $@ $(ALL_CFLAGS)
+binary/armsym.o:	$(ARM_COMMON_PATH)/armsym.c $(ARM_COMMON_PATH)/armsym.h
+	$(CC) -c $< -o $@ $(ALL_CFLAGS)
 #SIM_MMU_OBJS
 binary/arm7100_mmu.o: $(ARM_COMMON_PATH)/mmu/arm7100_mmu.c $(ARM_COMMON_PATH)/mmu/arm7100_mmu.h
 	$(CC)  $(ALL_CFLAGS) -c $< -o $@
